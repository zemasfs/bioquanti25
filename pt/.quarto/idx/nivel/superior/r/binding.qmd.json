{"title":"Interação molecular","markdown":{"yaml":{"title":"Interação molecular","toc":true,"lang":"pt","bibliography":"referencias.bib"},"headingText":"Interação ligante-biopolímero","headingAttr":{"id":"Binding","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n  \n  \n\n|       Quando se menciona interação entre biomoléculas, normalmente se faz referência à processos adsortivos envolvendo um biopolímero (proteína, ácido nucleico, glicano), e um ligante de baixo peso molecular, embora o formalismo também se aplique com alguma restrição a interações entre biopolímeros, e mesmo células inteiras.\n|       O formalismo mais comum para interação biomolecular é o que envolve a formação de complexo adsortivo entre uma proteína e um ligante (*ligand binding*), exemplificado para íons (Ca$^{2+}$, Mg$^{2+}$, etc), fármacos e candidatos, produtos naturais, e antígenos, dentre vários. \n|       Perguntas simples acerca da *interação ligante-proteína* podem elucidar diversas características da formação de tais complexos, como:\n\n1. Quanto de proteína/ligante estão presentes ?\n2. Quanto do complexo é formado ?\n3. Quão rápido o complexo associa/dissocia ?\n4. Quais os mecanismos envolvidos ?\n\n|       De modo geral, pode-se representar a interação ligante-proteína como segue:\n\n$$\nP+L \\begin{array}{c}\n_{k_{on}}\\\\\n \\rightleftharpoons\\\\\n^{k_{off}} \\end{array} PL \n$$ {#eq-diagPL}\n\n\nOnde *P* representa o teor de proteína livre, *L* o ligante livre, e *PL* o complexo formado. As taxas de reação são definidas para a formação (*k$_{on}$*; M$^{-1}$s$^{-1}$) e dissociação (*k$_{off}$*; s$^{-1}$) do complexo. \n\n|       Dessa forma deduz-se a equação para a *isoterma de interação* do ligante com a proteína como segue:\n\n\n$$\nKd=\\frac{[P]*[L]}{[P]+[L]}\n$$ {#eq-eqPL}\n\n\nOnde *Kd* representa a *constante de equilíbrio de dissociação* para o complexo *PL* formado, tal como condicionado ao equilíbrio de formação/dissociação do complexo (*v$_{assoc}$ = v$_{dissoc}$*), e também definido como: \n\n$$\nKd=\\frac{k_{off}}{k_{on}}\n$$ {#eq-eqKd}\n\n\n|       A partir da @eq-eqPL pode-se facilmente deduzir a expressão final para a interação de um ligante a um conjunto de sítios de mesma afinidade na proteína:\n\n$$\n\\nu=\\frac{n * [L]}{Kd + [L]}\n$$ {#eq-eqNu}\n\n## Modelos de Interação e Representações Lineares\n|       Observe que a @eq-eqNu praticamente repete o formalismo já visto com a formação do complexo ativado de enzima-substrato do capítulo de *Enzimas*, bem como sua representação resultante como uma hipérbole quadrática. De fato, ocorre essencialmente a substituição do parâmetro cinético *v* da reação pelo parâmetro termodinâmico $\\nu$ (\"nu\", do Grego) para a isoterma de ligação. As demais quantidades envolvidas mantém-se análogas (*P* no lugar de *E*; *L* no lugar de *S*;*Kd* no lugar de *Km*; e *n* no lugar de *Vmax*). \n|       Mantida essa similaridade com o formalismo da *equação de Michaelis-Menten*, da mesma maneira decorrem as linearizações para a @eq-eqNu), bem como ajustes não lineares à mesma, na busca de uma *solução analítica* para os parâmetros termodinâmicos *Kd* e *n*. Exemplificando um trecho de código para as linearizações mais comuns no tratamento de dados de interação ligante-proteína:\n\n```{r, echo=TRUE, figLinBind, warning=FALSE, fig.cap=\"Principais linearizações da isoterma de ligação ligante-proteína.\"}\n\n# Linearizações em interação bimolecular\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 1e-6\nn <- 1\nv <- n * L / (Kd + L)\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Desvios da linearidade, por outro lado, são frequentemente utilizados como diagnósticos para modelos que distintos do de *homogeneidade de sítios de ligação* como acima (*heterogeneidade de sítios*, *criação de sítio*, *cooperatividade*. As equações abaixo descrevem esses modelos, e consideram *K*, *constante de equilíbrio de associação ligante-proteína*, como o reverso de *Kd*, a fim de tornar as expressões mais legíveis:\n\n$$\nK = \\frac{1}{Kd}\n$$ {#eq-eqKdK}\n\n|       O *modelo de heterogeneidade de sítios* de ligação pressupõe que haja na proteína mais um sítio com afinidades distintas para o ligante [@dahlquist197813]. Formalmente esse modelo pode ser exemplificado para 2 conjuntos de sítios de ligação, como segue:\n\n$$\n\\nu=\\frac{K1*[L]}{1+K1*[L]} + \\frac{K2*[L]}{1+K2*[L]}\n$$ {#eq-eqHeterSit}\n\n\n|       O trecho de código abaixo exemplifica o modelo no `R`, bem como suas principais linearizações diagnósticas.\n\n```{r,figHeterSit, fig.cap=\"Modelo e linearizações para  heterogeneidade de 2 conjuntos de sítios de ligação\"}\n\n# Heterogeneidade de sítios de ligação\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 <- 2e-6\nn1 <- 1\nKd2 <- 2e-8\nn2 <- 1\nv <- (n1 * L / (Kd1 + L)) + (n2 * L / (Kd2 + L))\n\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n1 + n2 - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       O *modelo de criação de novo sítio* - \"one-site creator\"; [@parsons1978theoretical] estabelece uma cooperatividade positiva resultante da produção de novos sítios para o ligante na proteína. Segue o modelo exemplificado e suas linearizações resultantes.  \n\n```{r,figOneSitCreat, fig.cap=\"Modelo e linearizações para  criação de novo sítio: *1-site creator*.\"}\n\n# Criação de novo sítio sob interação com ligante\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 <- 2e-6\nn1 <- 1\nKd2 <- 2e-5\nn2 <- 1\nnH <- 0.5\nv <- (n1 * L * 1 / Kd1) / (1 + 1 / Kd1 * L) + \n  ((n2 * 1 / Kd1 * 1 / Kd2 * L^2) / (1 + 1 / Kd1 * L) * (1 + 1 / Kd2 * L))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Os *modelos de cooperatividade (negativa e positiva)* seguem um formalismo similar descrito para a ligação de oxigênio à hemoglobina no capítulos de *Proteínas*. Na *cooperatividade negativa* uma segunda molécula de ligante interage com a proteína com menor afinidade: \n\n```{r,figCoopNeg, fig.cap=\"Modelo e linearizações para  cooperatividade negativa de sítios de ligação.\"}\n\n# Cooperatividade negativa em ligand-binding\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 2e-6\nn <- 1\nnH <- 0.5\nv <- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Já na *cooperatividade positiva*, uma segunda molécula de ligante interage com a proteína com maior afinidade que a primeira molécula [@parsons1978theoretical]:\n\n```{r,figCoopPos, fig.cap=\"Modelo e linearizações para  cooperatividade positiva de sítios de ligação.\"}\n\n# Cooperatividade positiva em ligand binding\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 2e-6\nn <- 1\nnH <- 1.5\nv <- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Observe que a inclinação do gráfico de *Hill* é inferior à unidade para a *cooperatividade negativa*, e superior a essa, para a *cooperatividade positiva*, e representa o mesmo parâmetro *nH* visto no capítulo de *Proteinas*. \n|       Ainda que sujeito à crítica por sua inconsistência estatística (variável dependente em ambos os eixos), a representação de Scatchard tem sido privilegiada ao longo de décadas como diagnóstico de modelos de interação ligante-proteína. Entre suas vantagens, aloca-se a possibilidade de facilmente distinguir-se o modelo de cooperatividade positiva (aclive) do de heterogeneidade de sítios de ligação (declive abrupto) ou de cooperatividade negativa (declive suave).\n\n## Ajuste Não-Linear Em Interação Ligante-Proteína\n\n|       Ajustes diretos da equação não linear dos modelos de interação também podem ser efetuados como fora realizado para a equação de Michaelis-Menten no capítulo de *Enzimas*. Exemplificando, pode-se simular a obtenção de dados experimentais de *binding* pelo trecho a seguir, utilizando-se o comando 'runif' (*random uniform*) para geração de sequência aleatória (como fora realizado no capítulo de *Enzimas*). Para ilustrar, segue a @fig-1SitBindSimul.\n\n```{r, label= \"fig-1SitBindSimul\"}\n# Isoterma de Interação Ligante-Proteína\nn <- 1\nKd <- 10\nL <- 120\ni <- 3\nL <- seq(0, L, i)\nv <- (L * n) / (Kd + L) + rnorm(40, 0, 0.1)\nplot(L, v)\n```\n\n|       Observe que o comando 'rnorm' adiciona um erro de distribuição normal aos dados. Outra forma para simulação desses é dada abaixo, introduzindo-se o comando 'runif' de geração de números aleatórios.\n\n```{r, 1sitBindSimul2, echo=TRUE, fig.cap = \"Dados simulados para isoterma de interação bimolecular.\"}\n# Simulação de dados de interação bimolecular (1 sítio)\n\n# Simulação de dados\nset.seed(20160227) # estabelece semente para geração de números aleatórios\nL <- seq(0, 50, 1)\nPL <- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0  e max=1\n# 2. rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\nplot(L, PL, xlab = \"L\", ylab = \"PL\")\n```\n\n\n|       Agora precisamos utilizar o comando 'nls' para o ajuste não linear, sobreposição da curva teórica, e tabela estatística de resultados:\n\n```{r, nlsBind}\n# Ajuste não linear em ligand binding\nm <- nls(PL ~ n * L / (Kd + L), start = list(n = 1, Kd = 1))\n\n# Coef. de correlação\ncor(PL, predict(m)) # Coeficiente de correlação de Pearson\n\n# Gráfico de dados e simulação\nplot(L, PL)\nlines(L, predict(m), lty = 2, col = \"red\", lwd = 3)\nsummary(m)\n```\n\n\n## Sistemas Gráficos no R\n\n|       A última curva de simulação obtida o foi junto à biblioteca padrão para manipulação de gráficos da instalação do 'R', **Graphics**. Trata-se um conjunto de funções amplo também utilizado por vários outros pacotes do ambiente. Contudo, existem no 'R' diversas outras bibliotecas para elaboração de gráficos, dentre os quais vale destacar o *Lattice*, também incluido na instalação padrão, e o *ggplot2*. Ambos os sistemas geram resultados com melhor estética e flexibilidade gráfica que a biblioteca *Graphics* padrão, e possuem empregos e semânticas distintas entre si. \n|       O sistema *Lattice* [@sarkar2008lattice] é baseado no sistema *Trellis* para representação gráfica de dados multivariados. Sua força está na representação de dados em paineis contendo subgrupos e, embora tenha sintaxe menos intuitiva e por vezes mais elaborada que o pacote *Graphics*, produz um grafismo superior a esse com poucos cliques de teclado. De modo geral, o *Lattice* produz o gráfico dentro do próprio algoritmo, de modo diferente aos sistemas *Graphics* (pode-se acumular linhas sucessivas de modificação do gráfico) ou *ggplot2*.\n|      Por outro lado a biblioteca *ggplot2* é baseada na gramática de gráficos [@wickham2011ggplot2], e produz o gráfico utilizando uma única linha de comando que combina camadas sobrepostas, de modo similar à aplicativos de manipulação de imagens (ex: *Inkscape*, *Gimp*, *Corel Draw*, *Photoshop*). Dessa forma é possível alterar cada ítem do gráfico em suas camadas específicas (tema, coordenadas, facets, estatísticas, geometria, estética, dados). Exemplificando o resultado gráfico da curva de simulação acima de *binding* para *Lattice* e *ggplot2*:\n\n```{r, 1sitBindSimulLattice}\n# Os sistemas lattice e ggplot2\n\n# Simulação de dados\n\nset.seed(20160227) # estabelece semente para geração de números aleatórios\nL <- seq(0, 50, 1)\nPL <- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0  e max=1\n# 2. rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\n\n# Produção do gráfico com sistema Lattice\nlibrary(lattice)\nxyplot(PL ~ L)\n\n# Produção do gráfico com sistema ggplot2\nlibrary(ggplot2)\nqplot(L, PL)\n```\n\n|       Como a percepção de peculiaridades dos sistemas gráficos se revela melhor com dados mais elaborados, as ilustrações a seguir utilizarão o conjunto de dados 'Puromycin', que integra a biblioteca 'datasets' do 'R'. Os dados apresentam a velocidade de reação enzimática sobre um substrato em células tratadas e não tratadas com puromicina. \n\n\n\n\n|       O código abaixo retorna a plotagem, ajuste não linear e resultados obtidos com a biblioteca *Graphics* padrão, e foi extraído do própria documentação do *dataset*.\n\n```{r, puromycGraphics, fig.cap=\"Plotagem e análise com `graphics`.\" }\nlibrary(datasets)\n\n# O sistema base `graphics`\n\nplot(rate ~ conc,\n  data = Puromycin, las = 1,\n  xlab = \"[S], mM\",\n  ylab = \"v (contagem/min/min)\",\n  pch = as.integer(Puromycin$state),\n  col = as.integer(Puromycin$state),\n  main = \"Ilustração de Ajuste Com Graphics\"\n)\n\n## Ajuste da equação de Michaelis-Mentem\nfm1 <- nls(rate ~ Vm * conc / (K + conc),\n  data = Puromycin,\n  subset = state == \"treated\",\n  start = c(Vm = 200, K = 0.05)\n)\nfm2 <- nls(rate ~ Vm * conc / (K + conc),\n  data = Puromycin,\n  subset = state == \"untreated\",\n  start = c(Vm = 160, K = 0.05)\n)\nsummary(fm1)\nsummary(fm2)\n\n## Adição de linhas de ajuste ao plot\nconc <- seq(0, 1.2, length.out = 101)\nlines(conc, predict(fm1, list(conc = conc)), lty = 1, col = 1)\nlines(conc, predict(fm2, list(conc = conc)), lty = 2, col = 2)\nlegend(0.8, 120, levels(Puromycin$state),\n  col = 1:2, lty = 1:2, pch = 1:2\n)\n```\n\n|       O sistema *ggplot2*, por sua vez, exige que os comandos sejam elencados em camadas justapostas intercaladas com o sinal \"+\", como segue:\n\n```{r, puromycGgplot2, fig.cap=\"Plotagem e análise com ggplot2.\"}\n\n# Gráfico e análise com ggplot2\nlibrary(datasets)\np <- ggplot(data = Puromycin, aes(conc, rate, color = state)) +\n  geom_point() +\n  geom_smooth(\n    method       = \"nls\",\n    formula      = y ~ Vm * x / (Km + x),\n    method.args  = list(start = list(Vm = 200, Km = 0.1)),\n    se           = FALSE\n  ) # expressão que define o plot\np # variável que apresenta o plot\n```\n\n|       Perceba o menor número de instruções do *script* para a produção do gráfico. Além disso, e diferente do *Graphics*, *ggplot2* permite adicionar camadas à linha de comandos principais, e apresentar os dados multivariados em paineis (funções 'facet_grid' e 'facet_wrap'), sem a necessidade de se utilizar o comando 'mfrow' ou 'mfcol' visto no capítulo, como segue:\n\n```{r, puromycGgplot2Facet, fig.cap=\"Plotagem e análise com ggplot2 - paineis (faceting).\"}\np + facet_grid(rows = vars(state))\n```\n\n\n|       *Lattice* também possui uma economia de instruções em relação à *Graphics*. Não considerando o ajuste estatístico, os grupos podem ser apresentados simplesmente utilizando-se a fórmula:\n\n\n$$\nxyplot(y \\sim x~|~ groups = z)\n$$ {#eq-eqTrellis}\n\n\n```{r eval=TRUE, include=TRUE}\nlibrary(lattice)\nxyplot(rate ~ conc, data = Puromycin, groups = state)\n```\n\n|       E para a representação dos ajustes não lineares:\n\n\n```{r, eval=FALSE, include=TRUE, puromicLattice}\n\n# Um gráfico com dataset para lattice\n\nlibrary(nlme)\nn1 <- nlsList(rate ~ Vmax * conc / (Km + conc) | state, \n              data = Puromycin, start = list(Vmax = 200, Km = 0.1))\nsummary(n1)\nxyplot(rate ~ conc,\n  groups = state, data =\n    Puromycin\n) +\n  layer(panel.curve(Vmax[1] * x / (Km[1] + x), col = 1),\n    data = as.list(coef(n1))\n  ) +\n  layer(panel.curve(Vmax[2] * x / (Km[2] + x), col = 2),\n    data = as.list(coef(n1))\n  )\n```\n\n\n|       A biblioteca *Lattice* também permite a apresentação em paineis; diferente de *ggplot2*, contudo, o gráfico é gerado algoritmicamente, sem a sobreposição de comandos:\n\n\n```{r, puromicLatticePan, fig.cap= \"Plotagem e análise com Lattice - ajuste externo e paineis.\"}\n\n# Gráfico e análise não linear com lattice \n\nlibrary(nlme) # pacote quer permite regressão não linear com subgrupos\nnonlinLatt <- nlsList(rate ~ Vmax * conc / \n                        (Km + conc) | state, \n                      start = list(Vmax = 200, Km = 0.1), data = Puromycin)\nsummary(nonlinLatt)\nxyplot(rate + fitted(nonlinLatt) ~ conc | state,\n  data = Puromycin,\n  type = c(\"p\", \"l\"), distribute.type = TRUE, col.line = \"red\",\n  ylab = \"rate\"\n)\n```\n\n|       Das muitas diferenças que os pacotes *ggplot2* e *Lattice* apresentam, há uma que vale a pena ressaltar. Como visto acima, o *ggplot2* realiza o ajuste não linear dentro da linha de comandos de geração do gráfico, ao passo que o *Lattice* permite fazê-lo fora da linha. Isso é inerente do *ggplot2*, uma biblioteca desenhada para a produção de gráficos, e não para análises computacionais. Dessa forma o algoritmo que permite o ajuste não linear pelo *ggplot2*, ainda que seja o mesmo 'nls' já trabalhado, não expressa seus resultados explicitamente (embora haja formas de \"pescá-los\" utilizando-se outros pacotes).\n|       De certa forma, ainda que o *Lattice* exija uma curva de aprendizado menos intutiva, ele permite que se utilize os resultados estatísticos obtidos anteriormente para inclusão no algoritmo de plotagem. Isso é vantajoso quando se deseja outros algoritmos estatísticos para ajuste, como acima, ou mesmo sua flexibilização, além do 'nls' incluido em *ggplot2*. Não obstante, o *Lattice* também permite que se inclua a linha de ajuste dentro do próprio algoritmo, como abaixo:\n\n```{r,  warning=FALSE, puromicLatticePanInterno, fig.cap= \"Plotagem e análise com Lattice - ajuste interno e paineis.\" }\n\n# Ajuste não linear em paineis (Lattice)\n\nxyplot(rate ~ conc | state,\n  data = Puromycin,\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    n3 <- nls(y ~ Vmax * x / (Km + x), data = Puromycin, \n              start = list(Vmax = 200, Km = 0.1))\n    panel.lines(seq(0.02, 1.1, 0.02), \n                predict(n3, newdata = data.frame(x = seq(0.02, 1.1, 0.02))),\n                col.line = 2)\n  },\n  xlab = \"conc\", ylab = \"rate\"\n)\n```\n\n\n## Solução Numérica Para o Equilíbrio de Complexos Ligante-Proteína\n\n|       Como visto no capítulo de *Aminoácidos*, por vezes uma *solução numérica* pode ser empregada quando a *solução analítica* não converge, ou quando estamos diante de uma equação mais complexa. Nesse sentido a formação de complexos de que trata este subtítulo pode também ser tratada por uma solução numérica.\n|       Usualmente o tratamento dado para a solução numérica envolve encontrar as raízes de uma equação ou sistema de equações, ou seja:\n\n$$\nF(x) = 0\n$$ {#eq-eqFx}\n\n\n$$\nP+L \\rightleftarrows PL\n\\\\\nKd = \\frac{[P][L]}{[PL]}\n\\\\\nEntão,\\ [PL]=\\frac{[P][L]}{Kd}\n$$ {#eq-solNumEq}\n\n\n$$\n\\begin{cases}\n[Pt] = [P]+[PL] = [P]+\\frac{[P][L]}{Kd}\\\\\n[Lt] = [L]+[PL] = [L]+\\frac{[P][L]}{Kd}\n\\end{cases}\\\n$$ {#eq-solNumEq2}\n\n|       Assim, tem-se um sistema de equações lineares nos parâmetros (*[P]* livre, *[L]* livre, e complexo *[PL]*) que pode ser solucionado pelo `R` por diversas maneiras, uma das quais pela função de minimização `rootSolve`:\n\n\n```{r}\n# Cálculo de L, P, e PL em interação biomolecular para 1 conjunto de sítios\n# de mesma afinidade\nlibrary(rootSolve)\nPt <- 1\nLt <- 10\nKd <- 4\n\n# Modelo\nmodel <- function(x) c(x[1] + (x[1] * x[2]) / Kd - Pt, x[2] + \n                         (x[1] * x[2]) / Kd - Lt, Pt - x[1] - x[3])\n# o modelo acima deve conter uma lista de equações cuja igualdade é zero, \n# ou seja, f(x)=0\n(ss <- multiroot(model, c(1, 1, 1))) # comando de execução do \n# rootSolve (sementes pro algoritmo)\n```\n\n|       Dessa forma os valores resultantes (*f.root*) quando *[Lt]* = 10 são apresentados como *[P]* = 0,3, *[L]* = 9,3 e *[PL]* = 0,7.\n\n|       Outras soluções numéricas permitem um maior controle sobre o algoritmo empregado, tais como a função `optim` do `R` (limites de busca da solução, emprego de vetores, por ex). Para isso será exemplificado a mesma situação acima, embora apresentando uma variação do formalismo que relaciona *P*, *L* e *PL* :\n\n\n$$\n\\begin{cases}\n[PL] = [Pt]-[L]\\\\\n[PL] = [Lt]-[L]\\\\\n[P]*[L]=Kd*[PL]\n\\end{cases}\\\n$$ {#eq-solNumEq3}\n\n|       Dessa forma pode-se contruir uma relação quadrática envolvendo as três incógnitas:\n\n$$\n([Pt]-[L]-[PL])^2 + ([Lt]-[L]-[PL])^2 + ([P]*[L]-Kd*[PL])^2\n$$ {#eq-solNumEq4}\n\n\n|       Aplicando-se o algoritmo de minimização `optim` do `R`:\n\n```{r}\n# Cálculo de L, P, PL em interação para 1 sítio\n\nmodel2 <- function(x, Pt, Lt, K) {\n  L <- x[1]\n  P <- x[2]\n  PL <- x[3]\n  (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n} # declaração da função\nPt <- 1\nLt <- 10\nKd <- 4 # parâmetros da função\nsol2num <- optim(c(0.5, 1, .5), model2, method = \"L-BFGS-B\", \n                 lower = c(0, 0, 0), upper = c(Lt, Pt, Pt), Pt = Pt, Lt = Lt)\n# método BFGS permite bounds (lower, upper)\nsol2num$par # LF, PF, PL calculados\n```\n\n|       Perceba que são os mesmos resultados anteriores, embora com maior controle da solução. Agora pode-se utilizar essa minimização para criar um vetor de soluções para as três quantidades, como segue: \n\n```{r}\n# Declaração da função\nbind1 <- function(x, Pt, Lt, Kd) {\n  L <- x[1]\n  P <- x[2]\n  PL <- x[3]\n  (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n}\n\n# Parâmetros da função\nPt <- 1\nLt <- c(5, 10, 20)\nKd <- 4\n\n# Minimização (parâmetros para que a função acima dê zero)\ny <- function(i) {\n  optim(c(1, 1, 1), bind1,\n    method =\n      \"L-BFGS-B\", lower = c(0, 0, 0), upper = c(\n      Lt[i], Pt,\n      Pt\n    ), Lt = Lt[i], Pt = Pt, Kd = Kd\n  )\n}\n\n# Resultados em matriz\nypar <- function(i) y(i)$par\nyp <- matrix(\n  nrow = length(Lt), ncol = 2 + length(Kd),\n  byrow = T\n)\nfor (i in 1:length(Lt)) yp[i, ] <- y(i)$par\ncolnames(yp) <- c(\"L\", \"P\", \"PL\")\nrownames(yp) <- c(\"5\", \"10\", \"20\")\nyp\n```\n\n\n##  Cinética de Interação Ligante-Proteína e Solução Numérica\n\n|       Sob o mesmo princípio da solução numérica apresentada no ítem anterior para o equilíbrio da interação ligante-proteína, o `R` permite solução de mesma natureza para a cinética da formação dos complexos, ou seja, os teores de *P*, *L* e *PL* observados no tempo. Nesse caso pode-se desenvolver outras relações a partir da @eq-diagPL. Tomando-se por base que no equilíbrio as taxas cinéticas de *k$_{on}$* e *k$_{off}$* se igualam (*steady-state*), pode-se relacionar algumas equações diferenciais para a *associação*, bem como para a *dissociação* dos complexos:\n\n\n$$\nPara \\, a\\, associação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]\n\\end{cases}\n$$ {#eq-solNumKin}\n\n\n$$\nPara \\, a\\, dissociação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = -k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = k_{off}*[PL]\n\\end{cases}\n$$ {#eq-solNumKin2}\n\n|        Assim, as taxas globais resultantes para cada quantidade (taxa líquida) envolverá a soma das taxas de associação e dissociação de cada:\n\n$$\nTaxas \\, líquidas:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]-k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\n\\end{cases}\n$$ {#eq-solNumKin3}\n\n\n|       A solução para esse sistema final de equações diferenciais (taxas líquidas) envolve resolver a variação de cada quantidade (*$\\Delta$x*) num determinado intervalo de tempo (*$\\Delta$t*), tal que:\n\n\n$$\n\\Delta x=f(x)*\\Delta t\n$$ {#eq-eqDiff}\n\n|       Para isso é necessário utilizar uma biblioteca do `R` que permita a solução de um sistema de equações diferenciais. Entre as muitas soluções (`odeintr`, `pracma`, `rODE`), o emprego da biblioteca `deSolve`, que utiliza uma função para integração do sistema por algoritmo de *Runge-Kutta de 4a. ordem*:\n\n```{r,fig.cap=\"Teores de ligante e proteína livres (L e P), bem como do complexo PL  apresentados ao longo do tempo de acordo com o método Runge-Kutta de 4a. ordem para solução de equações diferenciais.\"}\n# Cinética de interação ligante-protéina para 1 conjunto de sítios\nlibrary(deSolve)\n\n# Condições experimentais\ntempo <- seq(0, 100) # intervalo de tempo\nparms <- c(kon = 0.02, koff = 0.001) # parâmetros do estado estacionário \n# da interação (uM^-1*s^-1 e s^-1, respectivamente)\nval.inic <- c(L = 0.8, P = 1, PL = 0) # valores iniciais, uM\n\n# Integração do sistema por Runge-Kutta de 4a. ordem\nsolNumKin <- function(t, x, parms) {\n  # definição da lista de parâmetros\n  L <- x[1] # ligante\n  P <- x[2] # proteína\n  PL <- x[3] # complexo\n\n  with(as.list(parms), {\n    # definição da lista de equações diferenciais\n    dL <- -kon * L * P + koff * PL\n    dP <- -kon * L * P + koff * PL\n    dPL <- kon * L * P - koff * PL\n    res <- c(dL, dP, dPL)\n    list(res)\n  })\n}\n\nsol.rk4 <- as.data.frame(rk4(\n  val.inic, tempo, solNumKin,\n  parms\n)) # rotina para Runge-Kutta 4a. ordem\n\n# Gráfico\nplot(sol.rk4$time, sol.rk4$L, type = \"l\", xlab = \"tempo\", \n     ylab = \"[composto], uM\")\nlegend(\"topright\", c(\"L\", \"P\", \"PL\"), \n       text.col = c(\"black\", \"red\", \"blue\"), bty = \"n\", lty = c(1, 2, 3))\nlines(sol.rk4$time, sol.rk4$P, type = \"l\", lty = 2, col = 2, lwd = 1.5)\nlines(sol.rk4$time, sol.rk4$PL, type = \"l\", lty = 3, col = 3, lwd = 1.5)\n```\n\n","srcMarkdownNoYaml":"\n  \n  \n## Interação ligante-biopolímero {#Binding}\n\n|       Quando se menciona interação entre biomoléculas, normalmente se faz referência à processos adsortivos envolvendo um biopolímero (proteína, ácido nucleico, glicano), e um ligante de baixo peso molecular, embora o formalismo também se aplique com alguma restrição a interações entre biopolímeros, e mesmo células inteiras.\n|       O formalismo mais comum para interação biomolecular é o que envolve a formação de complexo adsortivo entre uma proteína e um ligante (*ligand binding*), exemplificado para íons (Ca$^{2+}$, Mg$^{2+}$, etc), fármacos e candidatos, produtos naturais, e antígenos, dentre vários. \n|       Perguntas simples acerca da *interação ligante-proteína* podem elucidar diversas características da formação de tais complexos, como:\n\n1. Quanto de proteína/ligante estão presentes ?\n2. Quanto do complexo é formado ?\n3. Quão rápido o complexo associa/dissocia ?\n4. Quais os mecanismos envolvidos ?\n\n|       De modo geral, pode-se representar a interação ligante-proteína como segue:\n\n$$\nP+L \\begin{array}{c}\n_{k_{on}}\\\\\n \\rightleftharpoons\\\\\n^{k_{off}} \\end{array} PL \n$$ {#eq-diagPL}\n\n\nOnde *P* representa o teor de proteína livre, *L* o ligante livre, e *PL* o complexo formado. As taxas de reação são definidas para a formação (*k$_{on}$*; M$^{-1}$s$^{-1}$) e dissociação (*k$_{off}$*; s$^{-1}$) do complexo. \n\n|       Dessa forma deduz-se a equação para a *isoterma de interação* do ligante com a proteína como segue:\n\n\n$$\nKd=\\frac{[P]*[L]}{[P]+[L]}\n$$ {#eq-eqPL}\n\n\nOnde *Kd* representa a *constante de equilíbrio de dissociação* para o complexo *PL* formado, tal como condicionado ao equilíbrio de formação/dissociação do complexo (*v$_{assoc}$ = v$_{dissoc}$*), e também definido como: \n\n$$\nKd=\\frac{k_{off}}{k_{on}}\n$$ {#eq-eqKd}\n\n\n|       A partir da @eq-eqPL pode-se facilmente deduzir a expressão final para a interação de um ligante a um conjunto de sítios de mesma afinidade na proteína:\n\n$$\n\\nu=\\frac{n * [L]}{Kd + [L]}\n$$ {#eq-eqNu}\n\n## Modelos de Interação e Representações Lineares\n|       Observe que a @eq-eqNu praticamente repete o formalismo já visto com a formação do complexo ativado de enzima-substrato do capítulo de *Enzimas*, bem como sua representação resultante como uma hipérbole quadrática. De fato, ocorre essencialmente a substituição do parâmetro cinético *v* da reação pelo parâmetro termodinâmico $\\nu$ (\"nu\", do Grego) para a isoterma de ligação. As demais quantidades envolvidas mantém-se análogas (*P* no lugar de *E*; *L* no lugar de *S*;*Kd* no lugar de *Km*; e *n* no lugar de *Vmax*). \n|       Mantida essa similaridade com o formalismo da *equação de Michaelis-Menten*, da mesma maneira decorrem as linearizações para a @eq-eqNu), bem como ajustes não lineares à mesma, na busca de uma *solução analítica* para os parâmetros termodinâmicos *Kd* e *n*. Exemplificando um trecho de código para as linearizações mais comuns no tratamento de dados de interação ligante-proteína:\n\n```{r, echo=TRUE, figLinBind, warning=FALSE, fig.cap=\"Principais linearizações da isoterma de ligação ligante-proteína.\"}\n\n# Linearizações em interação bimolecular\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 1e-6\nn <- 1\nv <- n * L / (Kd + L)\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\")\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Desvios da linearidade, por outro lado, são frequentemente utilizados como diagnósticos para modelos que distintos do de *homogeneidade de sítios de ligação* como acima (*heterogeneidade de sítios*, *criação de sítio*, *cooperatividade*. As equações abaixo descrevem esses modelos, e consideram *K*, *constante de equilíbrio de associação ligante-proteína*, como o reverso de *Kd*, a fim de tornar as expressões mais legíveis:\n\n$$\nK = \\frac{1}{Kd}\n$$ {#eq-eqKdK}\n\n|       O *modelo de heterogeneidade de sítios* de ligação pressupõe que haja na proteína mais um sítio com afinidades distintas para o ligante [@dahlquist197813]. Formalmente esse modelo pode ser exemplificado para 2 conjuntos de sítios de ligação, como segue:\n\n$$\n\\nu=\\frac{K1*[L]}{1+K1*[L]} + \\frac{K2*[L]}{1+K2*[L]}\n$$ {#eq-eqHeterSit}\n\n\n|       O trecho de código abaixo exemplifica o modelo no `R`, bem como suas principais linearizações diagnósticas.\n\n```{r,figHeterSit, fig.cap=\"Modelo e linearizações para  heterogeneidade de 2 conjuntos de sítios de ligação\"}\n\n# Heterogeneidade de sítios de ligação\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 <- 2e-6\nn1 <- 1\nKd2 <- 2e-8\nn2 <- 1\nv <- (n1 * L / (Kd1 + L)) + (n2 * L / (Kd2 + L))\n\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n1 + n2 - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       O *modelo de criação de novo sítio* - \"one-site creator\"; [@parsons1978theoretical] estabelece uma cooperatividade positiva resultante da produção de novos sítios para o ligante na proteína. Segue o modelo exemplificado e suas linearizações resultantes.  \n\n```{r,figOneSitCreat, fig.cap=\"Modelo e linearizações para  criação de novo sítio: *1-site creator*.\"}\n\n# Criação de novo sítio sob interação com ligante\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd1 <- 2e-6\nn1 <- 1\nKd2 <- 2e-5\nn2 <- 1\nnH <- 0.5\nv <- (n1 * L * 1 / Kd1) / (1 + 1 / Kd1 * L) + \n  ((n2 * 1 / Kd1 * 1 / Kd2 * L^2) / (1 + 1 / Kd1 * L) * (1 + 1 / Kd2 * L))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Os *modelos de cooperatividade (negativa e positiva)* seguem um formalismo similar descrito para a ligação de oxigênio à hemoglobina no capítulos de *Proteínas*. Na *cooperatividade negativa* uma segunda molécula de ligante interage com a proteína com menor afinidade: \n\n```{r,figCoopNeg, fig.cap=\"Modelo e linearizações para  cooperatividade negativa de sítios de ligação.\"}\n\n# Cooperatividade negativa em ligand-binding\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 2e-6\nn <- 1\nnH <- 0.5\nv <- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Já na *cooperatividade positiva*, uma segunda molécula de ligante interage com a proteína com maior afinidade que a primeira molécula [@parsons1978theoretical]:\n\n```{r,figCoopPos, fig.cap=\"Modelo e linearizações para  cooperatividade positiva de sítios de ligação.\"}\n\n# Cooperatividade positiva em ligand binding\n\nL <- c(0.1, 0.2, 0.5, 1, 5, 10, 20) * 1e-6\nKd <- 2e-6\nn <- 1\nnH <- 1.5\nv <- (n * L^nH / (Kd + L^nH))\npar(mfrow = c(2, 3)) # estabelece área de plot pra 6 gráficos\nplot(L, v, type = \"o\", main = \"Direto\")\nplot(log(L), v, type = \"o\", main = \"Langmuir\")\nplot(1 / L, 1 / v, type = \"o\", main = \"Klotz\")\nplot(v, v / L, type = \"o\", main = \"Scatchard\")\nplot(L, L / v, type = \"o\", main = \"Woolf\")\nplot(log10(L), log10(v / (n - v)), type = \"o\", main = \"Hill\") \n# n1+n2=ntot no Hill\npar(mfrow = c(1, 1)) # volta à janela gráfica normal\n```\n\n|       Observe que a inclinação do gráfico de *Hill* é inferior à unidade para a *cooperatividade negativa*, e superior a essa, para a *cooperatividade positiva*, e representa o mesmo parâmetro *nH* visto no capítulo de *Proteinas*. \n|       Ainda que sujeito à crítica por sua inconsistência estatística (variável dependente em ambos os eixos), a representação de Scatchard tem sido privilegiada ao longo de décadas como diagnóstico de modelos de interação ligante-proteína. Entre suas vantagens, aloca-se a possibilidade de facilmente distinguir-se o modelo de cooperatividade positiva (aclive) do de heterogeneidade de sítios de ligação (declive abrupto) ou de cooperatividade negativa (declive suave).\n\n## Ajuste Não-Linear Em Interação Ligante-Proteína\n\n|       Ajustes diretos da equação não linear dos modelos de interação também podem ser efetuados como fora realizado para a equação de Michaelis-Menten no capítulo de *Enzimas*. Exemplificando, pode-se simular a obtenção de dados experimentais de *binding* pelo trecho a seguir, utilizando-se o comando 'runif' (*random uniform*) para geração de sequência aleatória (como fora realizado no capítulo de *Enzimas*). Para ilustrar, segue a @fig-1SitBindSimul.\n\n```{r, label= \"fig-1SitBindSimul\"}\n# Isoterma de Interação Ligante-Proteína\nn <- 1\nKd <- 10\nL <- 120\ni <- 3\nL <- seq(0, L, i)\nv <- (L * n) / (Kd + L) + rnorm(40, 0, 0.1)\nplot(L, v)\n```\n\n|       Observe que o comando 'rnorm' adiciona um erro de distribuição normal aos dados. Outra forma para simulação desses é dada abaixo, introduzindo-se o comando 'runif' de geração de números aleatórios.\n\n```{r, 1sitBindSimul2, echo=TRUE, fig.cap = \"Dados simulados para isoterma de interação bimolecular.\"}\n# Simulação de dados de interação bimolecular (1 sítio)\n\n# Simulação de dados\nset.seed(20160227) # estabelece semente para geração de números aleatórios\nL <- seq(0, 50, 1)\nPL <- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0  e max=1\n# 2. rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\nplot(L, PL, xlab = \"L\", ylab = \"PL\")\n```\n\n\n|       Agora precisamos utilizar o comando 'nls' para o ajuste não linear, sobreposição da curva teórica, e tabela estatística de resultados:\n\n```{r, nlsBind}\n# Ajuste não linear em ligand binding\nm <- nls(PL ~ n * L / (Kd + L), start = list(n = 1, Kd = 1))\n\n# Coef. de correlação\ncor(PL, predict(m)) # Coeficiente de correlação de Pearson\n\n# Gráfico de dados e simulação\nplot(L, PL)\nlines(L, predict(m), lty = 2, col = \"red\", lwd = 3)\nsummary(m)\n```\n\n\n## Sistemas Gráficos no R\n\n|       A última curva de simulação obtida o foi junto à biblioteca padrão para manipulação de gráficos da instalação do 'R', **Graphics**. Trata-se um conjunto de funções amplo também utilizado por vários outros pacotes do ambiente. Contudo, existem no 'R' diversas outras bibliotecas para elaboração de gráficos, dentre os quais vale destacar o *Lattice*, também incluido na instalação padrão, e o *ggplot2*. Ambos os sistemas geram resultados com melhor estética e flexibilidade gráfica que a biblioteca *Graphics* padrão, e possuem empregos e semânticas distintas entre si. \n|       O sistema *Lattice* [@sarkar2008lattice] é baseado no sistema *Trellis* para representação gráfica de dados multivariados. Sua força está na representação de dados em paineis contendo subgrupos e, embora tenha sintaxe menos intuitiva e por vezes mais elaborada que o pacote *Graphics*, produz um grafismo superior a esse com poucos cliques de teclado. De modo geral, o *Lattice* produz o gráfico dentro do próprio algoritmo, de modo diferente aos sistemas *Graphics* (pode-se acumular linhas sucessivas de modificação do gráfico) ou *ggplot2*.\n|      Por outro lado a biblioteca *ggplot2* é baseada na gramática de gráficos [@wickham2011ggplot2], e produz o gráfico utilizando uma única linha de comando que combina camadas sobrepostas, de modo similar à aplicativos de manipulação de imagens (ex: *Inkscape*, *Gimp*, *Corel Draw*, *Photoshop*). Dessa forma é possível alterar cada ítem do gráfico em suas camadas específicas (tema, coordenadas, facets, estatísticas, geometria, estética, dados). Exemplificando o resultado gráfico da curva de simulação acima de *binding* para *Lattice* e *ggplot2*:\n\n```{r, 1sitBindSimulLattice}\n# Os sistemas lattice e ggplot2\n\n# Simulação de dados\n\nset.seed(20160227) # estabelece semente para geração de números aleatórios\nL <- seq(0, 50, 1)\nPL <- ((runif(1, 10, 20) * L) / (runif(1, 0, 10) + L)) + rnorm(51, 0, 1)\n# 1. runif(n,min,max); quando sem atributos, considera-se min=0  e max=1\n# 2. rnorm(no. pontos,media,desvio) - erro aleatório de distribuição normal\n\n# Produção do gráfico com sistema Lattice\nlibrary(lattice)\nxyplot(PL ~ L)\n\n# Produção do gráfico com sistema ggplot2\nlibrary(ggplot2)\nqplot(L, PL)\n```\n\n|       Como a percepção de peculiaridades dos sistemas gráficos se revela melhor com dados mais elaborados, as ilustrações a seguir utilizarão o conjunto de dados 'Puromycin', que integra a biblioteca 'datasets' do 'R'. Os dados apresentam a velocidade de reação enzimática sobre um substrato em células tratadas e não tratadas com puromicina. \n\n\n\n\n|       O código abaixo retorna a plotagem, ajuste não linear e resultados obtidos com a biblioteca *Graphics* padrão, e foi extraído do própria documentação do *dataset*.\n\n```{r, puromycGraphics, fig.cap=\"Plotagem e análise com `graphics`.\" }\nlibrary(datasets)\n\n# O sistema base `graphics`\n\nplot(rate ~ conc,\n  data = Puromycin, las = 1,\n  xlab = \"[S], mM\",\n  ylab = \"v (contagem/min/min)\",\n  pch = as.integer(Puromycin$state),\n  col = as.integer(Puromycin$state),\n  main = \"Ilustração de Ajuste Com Graphics\"\n)\n\n## Ajuste da equação de Michaelis-Mentem\nfm1 <- nls(rate ~ Vm * conc / (K + conc),\n  data = Puromycin,\n  subset = state == \"treated\",\n  start = c(Vm = 200, K = 0.05)\n)\nfm2 <- nls(rate ~ Vm * conc / (K + conc),\n  data = Puromycin,\n  subset = state == \"untreated\",\n  start = c(Vm = 160, K = 0.05)\n)\nsummary(fm1)\nsummary(fm2)\n\n## Adição de linhas de ajuste ao plot\nconc <- seq(0, 1.2, length.out = 101)\nlines(conc, predict(fm1, list(conc = conc)), lty = 1, col = 1)\nlines(conc, predict(fm2, list(conc = conc)), lty = 2, col = 2)\nlegend(0.8, 120, levels(Puromycin$state),\n  col = 1:2, lty = 1:2, pch = 1:2\n)\n```\n\n|       O sistema *ggplot2*, por sua vez, exige que os comandos sejam elencados em camadas justapostas intercaladas com o sinal \"+\", como segue:\n\n```{r, puromycGgplot2, fig.cap=\"Plotagem e análise com ggplot2.\"}\n\n# Gráfico e análise com ggplot2\nlibrary(datasets)\np <- ggplot(data = Puromycin, aes(conc, rate, color = state)) +\n  geom_point() +\n  geom_smooth(\n    method       = \"nls\",\n    formula      = y ~ Vm * x / (Km + x),\n    method.args  = list(start = list(Vm = 200, Km = 0.1)),\n    se           = FALSE\n  ) # expressão que define o plot\np # variável que apresenta o plot\n```\n\n|       Perceba o menor número de instruções do *script* para a produção do gráfico. Além disso, e diferente do *Graphics*, *ggplot2* permite adicionar camadas à linha de comandos principais, e apresentar os dados multivariados em paineis (funções 'facet_grid' e 'facet_wrap'), sem a necessidade de se utilizar o comando 'mfrow' ou 'mfcol' visto no capítulo, como segue:\n\n```{r, puromycGgplot2Facet, fig.cap=\"Plotagem e análise com ggplot2 - paineis (faceting).\"}\np + facet_grid(rows = vars(state))\n```\n\n\n|       *Lattice* também possui uma economia de instruções em relação à *Graphics*. Não considerando o ajuste estatístico, os grupos podem ser apresentados simplesmente utilizando-se a fórmula:\n\n\n$$\nxyplot(y \\sim x~|~ groups = z)\n$$ {#eq-eqTrellis}\n\n\n```{r eval=TRUE, include=TRUE}\nlibrary(lattice)\nxyplot(rate ~ conc, data = Puromycin, groups = state)\n```\n\n|       E para a representação dos ajustes não lineares:\n\n\n```{r, eval=FALSE, include=TRUE, puromicLattice}\n\n# Um gráfico com dataset para lattice\n\nlibrary(nlme)\nn1 <- nlsList(rate ~ Vmax * conc / (Km + conc) | state, \n              data = Puromycin, start = list(Vmax = 200, Km = 0.1))\nsummary(n1)\nxyplot(rate ~ conc,\n  groups = state, data =\n    Puromycin\n) +\n  layer(panel.curve(Vmax[1] * x / (Km[1] + x), col = 1),\n    data = as.list(coef(n1))\n  ) +\n  layer(panel.curve(Vmax[2] * x / (Km[2] + x), col = 2),\n    data = as.list(coef(n1))\n  )\n```\n\n\n|       A biblioteca *Lattice* também permite a apresentação em paineis; diferente de *ggplot2*, contudo, o gráfico é gerado algoritmicamente, sem a sobreposição de comandos:\n\n\n```{r, puromicLatticePan, fig.cap= \"Plotagem e análise com Lattice - ajuste externo e paineis.\"}\n\n# Gráfico e análise não linear com lattice \n\nlibrary(nlme) # pacote quer permite regressão não linear com subgrupos\nnonlinLatt <- nlsList(rate ~ Vmax * conc / \n                        (Km + conc) | state, \n                      start = list(Vmax = 200, Km = 0.1), data = Puromycin)\nsummary(nonlinLatt)\nxyplot(rate + fitted(nonlinLatt) ~ conc | state,\n  data = Puromycin,\n  type = c(\"p\", \"l\"), distribute.type = TRUE, col.line = \"red\",\n  ylab = \"rate\"\n)\n```\n\n|       Das muitas diferenças que os pacotes *ggplot2* e *Lattice* apresentam, há uma que vale a pena ressaltar. Como visto acima, o *ggplot2* realiza o ajuste não linear dentro da linha de comandos de geração do gráfico, ao passo que o *Lattice* permite fazê-lo fora da linha. Isso é inerente do *ggplot2*, uma biblioteca desenhada para a produção de gráficos, e não para análises computacionais. Dessa forma o algoritmo que permite o ajuste não linear pelo *ggplot2*, ainda que seja o mesmo 'nls' já trabalhado, não expressa seus resultados explicitamente (embora haja formas de \"pescá-los\" utilizando-se outros pacotes).\n|       De certa forma, ainda que o *Lattice* exija uma curva de aprendizado menos intutiva, ele permite que se utilize os resultados estatísticos obtidos anteriormente para inclusão no algoritmo de plotagem. Isso é vantajoso quando se deseja outros algoritmos estatísticos para ajuste, como acima, ou mesmo sua flexibilização, além do 'nls' incluido em *ggplot2*. Não obstante, o *Lattice* também permite que se inclua a linha de ajuste dentro do próprio algoritmo, como abaixo:\n\n```{r,  warning=FALSE, puromicLatticePanInterno, fig.cap= \"Plotagem e análise com Lattice - ajuste interno e paineis.\" }\n\n# Ajuste não linear em paineis (Lattice)\n\nxyplot(rate ~ conc | state,\n  data = Puromycin,\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    n3 <- nls(y ~ Vmax * x / (Km + x), data = Puromycin, \n              start = list(Vmax = 200, Km = 0.1))\n    panel.lines(seq(0.02, 1.1, 0.02), \n                predict(n3, newdata = data.frame(x = seq(0.02, 1.1, 0.02))),\n                col.line = 2)\n  },\n  xlab = \"conc\", ylab = \"rate\"\n)\n```\n\n\n## Solução Numérica Para o Equilíbrio de Complexos Ligante-Proteína\n\n|       Como visto no capítulo de *Aminoácidos*, por vezes uma *solução numérica* pode ser empregada quando a *solução analítica* não converge, ou quando estamos diante de uma equação mais complexa. Nesse sentido a formação de complexos de que trata este subtítulo pode também ser tratada por uma solução numérica.\n|       Usualmente o tratamento dado para a solução numérica envolve encontrar as raízes de uma equação ou sistema de equações, ou seja:\n\n$$\nF(x) = 0\n$$ {#eq-eqFx}\n\n\n$$\nP+L \\rightleftarrows PL\n\\\\\nKd = \\frac{[P][L]}{[PL]}\n\\\\\nEntão,\\ [PL]=\\frac{[P][L]}{Kd}\n$$ {#eq-solNumEq}\n\n\n$$\n\\begin{cases}\n[Pt] = [P]+[PL] = [P]+\\frac{[P][L]}{Kd}\\\\\n[Lt] = [L]+[PL] = [L]+\\frac{[P][L]}{Kd}\n\\end{cases}\\\n$$ {#eq-solNumEq2}\n\n|       Assim, tem-se um sistema de equações lineares nos parâmetros (*[P]* livre, *[L]* livre, e complexo *[PL]*) que pode ser solucionado pelo `R` por diversas maneiras, uma das quais pela função de minimização `rootSolve`:\n\n\n```{r}\n# Cálculo de L, P, e PL em interação biomolecular para 1 conjunto de sítios\n# de mesma afinidade\nlibrary(rootSolve)\nPt <- 1\nLt <- 10\nKd <- 4\n\n# Modelo\nmodel <- function(x) c(x[1] + (x[1] * x[2]) / Kd - Pt, x[2] + \n                         (x[1] * x[2]) / Kd - Lt, Pt - x[1] - x[3])\n# o modelo acima deve conter uma lista de equações cuja igualdade é zero, \n# ou seja, f(x)=0\n(ss <- multiroot(model, c(1, 1, 1))) # comando de execução do \n# rootSolve (sementes pro algoritmo)\n```\n\n|       Dessa forma os valores resultantes (*f.root*) quando *[Lt]* = 10 são apresentados como *[P]* = 0,3, *[L]* = 9,3 e *[PL]* = 0,7.\n\n|       Outras soluções numéricas permitem um maior controle sobre o algoritmo empregado, tais como a função `optim` do `R` (limites de busca da solução, emprego de vetores, por ex). Para isso será exemplificado a mesma situação acima, embora apresentando uma variação do formalismo que relaciona *P*, *L* e *PL* :\n\n\n$$\n\\begin{cases}\n[PL] = [Pt]-[L]\\\\\n[PL] = [Lt]-[L]\\\\\n[P]*[L]=Kd*[PL]\n\\end{cases}\\\n$$ {#eq-solNumEq3}\n\n|       Dessa forma pode-se contruir uma relação quadrática envolvendo as três incógnitas:\n\n$$\n([Pt]-[L]-[PL])^2 + ([Lt]-[L]-[PL])^2 + ([P]*[L]-Kd*[PL])^2\n$$ {#eq-solNumEq4}\n\n\n|       Aplicando-se o algoritmo de minimização `optim` do `R`:\n\n```{r}\n# Cálculo de L, P, PL em interação para 1 sítio\n\nmodel2 <- function(x, Pt, Lt, K) {\n  L <- x[1]\n  P <- x[2]\n  PL <- x[3]\n  (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n} # declaração da função\nPt <- 1\nLt <- 10\nKd <- 4 # parâmetros da função\nsol2num <- optim(c(0.5, 1, .5), model2, method = \"L-BFGS-B\", \n                 lower = c(0, 0, 0), upper = c(Lt, Pt, Pt), Pt = Pt, Lt = Lt)\n# método BFGS permite bounds (lower, upper)\nsol2num$par # LF, PF, PL calculados\n```\n\n|       Perceba que são os mesmos resultados anteriores, embora com maior controle da solução. Agora pode-se utilizar essa minimização para criar um vetor de soluções para as três quantidades, como segue: \n\n```{r}\n# Declaração da função\nbind1 <- function(x, Pt, Lt, Kd) {\n  L <- x[1]\n  P <- x[2]\n  PL <- x[3]\n  (Pt - P - PL)^2 + (Lt - L - PL)^2 + (P * L - Kd * PL)^2\n}\n\n# Parâmetros da função\nPt <- 1\nLt <- c(5, 10, 20)\nKd <- 4\n\n# Minimização (parâmetros para que a função acima dê zero)\ny <- function(i) {\n  optim(c(1, 1, 1), bind1,\n    method =\n      \"L-BFGS-B\", lower = c(0, 0, 0), upper = c(\n      Lt[i], Pt,\n      Pt\n    ), Lt = Lt[i], Pt = Pt, Kd = Kd\n  )\n}\n\n# Resultados em matriz\nypar <- function(i) y(i)$par\nyp <- matrix(\n  nrow = length(Lt), ncol = 2 + length(Kd),\n  byrow = T\n)\nfor (i in 1:length(Lt)) yp[i, ] <- y(i)$par\ncolnames(yp) <- c(\"L\", \"P\", \"PL\")\nrownames(yp) <- c(\"5\", \"10\", \"20\")\nyp\n```\n\n\n##  Cinética de Interação Ligante-Proteína e Solução Numérica\n\n|       Sob o mesmo princípio da solução numérica apresentada no ítem anterior para o equilíbrio da interação ligante-proteína, o `R` permite solução de mesma natureza para a cinética da formação dos complexos, ou seja, os teores de *P*, *L* e *PL* observados no tempo. Nesse caso pode-se desenvolver outras relações a partir da @eq-diagPL. Tomando-se por base que no equilíbrio as taxas cinéticas de *k$_{on}$* e *k$_{off}$* se igualam (*steady-state*), pode-se relacionar algumas equações diferenciais para a *associação*, bem como para a *dissociação* dos complexos:\n\n\n$$\nPara \\, a\\, associação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]\n\\end{cases}\n$$ {#eq-solNumKin}\n\n\n$$\nPara \\, a\\, dissociação:\n\\begin{cases}\n\\frac{d[PL]}{dt} = -k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = k_{off}*[PL]\n\\end{cases}\n$$ {#eq-solNumKin2}\n\n|        Assim, as taxas globais resultantes para cada quantidade (taxa líquida) envolverá a soma das taxas de associação e dissociação de cada:\n\n$$\nTaxas \\, líquidas:\n\\begin{cases}\n\\frac{d[PL]}{dt} = k_{on}*[L]*[P]-k_{off}*[PL]\\\\\n\\frac{d[L]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\\\\\n\\frac{d[P]}{dt} = -k_{on}*[L]*[P]+k_{off}*[PL]\n\\end{cases}\n$$ {#eq-solNumKin3}\n\n\n|       A solução para esse sistema final de equações diferenciais (taxas líquidas) envolve resolver a variação de cada quantidade (*$\\Delta$x*) num determinado intervalo de tempo (*$\\Delta$t*), tal que:\n\n\n$$\n\\Delta x=f(x)*\\Delta t\n$$ {#eq-eqDiff}\n\n|       Para isso é necessário utilizar uma biblioteca do `R` que permita a solução de um sistema de equações diferenciais. Entre as muitas soluções (`odeintr`, `pracma`, `rODE`), o emprego da biblioteca `deSolve`, que utiliza uma função para integração do sistema por algoritmo de *Runge-Kutta de 4a. ordem*:\n\n```{r,fig.cap=\"Teores de ligante e proteína livres (L e P), bem como do complexo PL  apresentados ao longo do tempo de acordo com o método Runge-Kutta de 4a. ordem para solução de equações diferenciais.\"}\n# Cinética de interação ligante-protéina para 1 conjunto de sítios\nlibrary(deSolve)\n\n# Condições experimentais\ntempo <- seq(0, 100) # intervalo de tempo\nparms <- c(kon = 0.02, koff = 0.001) # parâmetros do estado estacionário \n# da interação (uM^-1*s^-1 e s^-1, respectivamente)\nval.inic <- c(L = 0.8, P = 1, PL = 0) # valores iniciais, uM\n\n# Integração do sistema por Runge-Kutta de 4a. ordem\nsolNumKin <- function(t, x, parms) {\n  # definição da lista de parâmetros\n  L <- x[1] # ligante\n  P <- x[2] # proteína\n  PL <- x[3] # complexo\n\n  with(as.list(parms), {\n    # definição da lista de equações diferenciais\n    dL <- -kon * L * P + koff * PL\n    dP <- -kon * L * P + koff * PL\n    dPL <- kon * L * P - koff * PL\n    res <- c(dL, dP, dPL)\n    list(res)\n  })\n}\n\nsol.rk4 <- as.data.frame(rk4(\n  val.inic, tempo, solNumKin,\n  parms\n)) # rotina para Runge-Kutta 4a. ordem\n\n# Gráfico\nplot(sol.rk4$time, sol.rk4$L, type = \"l\", xlab = \"tempo\", \n     ylab = \"[composto], uM\")\nlegend(\"topright\", c(\"L\", \"P\", \"PL\"), \n       text.col = c(\"black\", \"red\", \"blue\"), bty = \"n\", lty = c(1, 2, 3))\nlines(sol.rk4$time, sol.rk4$P, type = \"l\", lty = 2, col = 2, lwd = 1.5)\nlines(sol.rk4$time, sol.rk4$PL, type = \"l\", lty = 3, col = 3, lwd = 1.5)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"binding.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","other-links-title":"Outros Links","code-links-title":"Ligações de código","launch-dev-container-title":"Iniciar Dev Container","launch-binder-title":"Iniciar Binder","article-notebook-label":"Caderno do Artigo","notebook-preview-download":"Baixar Caderno","notebook-preview-download-src":"Descarregar código fonte","notebook-preview-back":"Voltar ao Artigo","manuscript-meca-bundle":"Arquivo MECA","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Ver Licença","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","title-block-keywords":"Palavras-chave","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","tools-share":"Share","tools-download":"Download","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjetura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-wordcount":"Contagem de Palavras","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente","listing-page-words":"{0} palavras","listing-page-filter":"Filtro","draft":"Rascunho"},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.7.32","theme":{"light":"flatly"},"title":"Interação molecular","bibliography":["referencias.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}